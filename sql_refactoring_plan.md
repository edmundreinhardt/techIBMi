# SQL Refactoring Plan for IBM i Application

## 1. Current DDS-Based Database Structure Analysis

### Physical Files

#### COUNTRY.PF
```
R FCOUN
  COID      R        # Country ID (key field, reference field)
  COUNTR    R        # Country name (reference field)
  COISO          3   # 3-character ISO country code
K COID             # Key field
```

#### CUSTOME1 (inferred from code)
```
R FCUST
  CUID              # Customer ID
  CUSTNM            # Customer name
  CUPHONE           # Customer phone number
  CUCOUN            # Country code (references COUNTRY.PF)
  CULASTORD         # Date of last order
  CUMOD             # Last modification timestamp
  CUMODID           # User who last modified the record
  CUCREA            # Creation date
K CUID             # Key field (inferred)
```

### Logical Files

#### COUNTR1.LF
```
R FCOUN                     PFILE(COUNTRY)
K COUNTR                   # Keyed by country name instead of ID
```

#### CUSTOME2 (inferred from code)
```
R FCUST                     PFILE(CUSTOME1)
K CUSTNM                   # Likely keyed by customer name (inferred)
```

## 2. SQL DDL Equivalents

### Tables (replacing Physical Files)

#### COUNTRY Table
```sql
CREATE TABLE COUNTRY (
    COID CHAR(2) NOT NULL,
    COUNTR VARCHAR(50) NOT NULL,
    COISO CHAR(3) NOT NULL,
    PRIMARY KEY (COID)
);

-- Add metadata comments
LABEL ON TABLE COUNTRY IS 'Country file';
LABEL ON COLUMN COUNTRY.COID IS 'Country ID';
LABEL ON COLUMN COUNTRY.COUNTR IS 'Country name';
LABEL ON COLUMN COUNTRY.COISO IS 'ISO country code';
```

#### CUSTOMER Table (replacing CUSTOME1)
```sql
CREATE TABLE CUSTOMER (
    CUID INTEGER NOT NULL GENERATED BY DEFAULT AS IDENTITY,
    CUSTNM VARCHAR(50) NOT NULL,
    CUPHONE VARCHAR(20) NOT NULL,
    CUCOUN CHAR(2) NOT NULL,
    CULASTORD DATE,
    CUMOD TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    CUMODID VARCHAR(10) NOT NULL,
    CUCREA DATE NOT NULL,
    PRIMARY KEY (CUID),
    FOREIGN KEY (CUCOUN) REFERENCES COUNTRY (COID)
);

-- Add metadata comments
LABEL ON TABLE CUSTOMER IS 'Customer file';
LABEL ON COLUMN CUSTOMER.CUID IS 'Customer ID';
LABEL ON COLUMN CUSTOMER.CUSTNM IS 'Customer name';
LABEL ON COLUMN CUSTOMER.CUPHONE IS 'Customer phone number';
LABEL ON COLUMN CUSTOMER.CUCOUN IS 'Country code';
LABEL ON COLUMN CUSTOMER.CULASTORD IS 'Date of last order';
LABEL ON COLUMN CUSTOMER.CUMOD IS 'Last modification timestamp';
LABEL ON COLUMN CUSTOMER.CUMODID IS 'User who last modified the record';
LABEL ON COLUMN CUSTOMER.CUCREA IS 'Creation date';
```

### Indexes (replacing Logical Files)

#### COUNTR1 Index
```sql
CREATE INDEX COUNTR1 ON COUNTRY (COUNTR);
```

#### CUSTOME2 Index
```sql
CREATE INDEX CUSTOME2 ON CUSTOMER (CUSTNM);
```

### Views (for additional compatibility)

#### COUNTRY_VIEW
```sql
CREATE VIEW COUNTRY_VIEW AS
SELECT COID, COUNTR, COISO
FROM COUNTRY;
```

#### CUSTOMER_VIEW
```sql
CREATE VIEW CUSTOMER_VIEW AS
SELECT CUID, CUSTNM, CUPHONE, CUCOUN, CULASTORD, CUMOD, CUMODID, CUCREA
FROM CUSTOMER;
```

## 3. SQL-Based Data Access Layer

### Service Module Refactoring Strategy

#### COU300.SQLRPGLE (replacing COU300.RPGLE)

Convert the existing record-level access code to embedded SQL:

```rpgle
h nomain

/copy qprotosrc,COUNTRY

d chainCOUNTRY    pr
D P_COID                         2A    value

D K_COID          S                   LIKE(COID)

*=============================================
PGetCountryName   B                     export
DGetCountryName   PI                   like(countr)
D P_COID                         2A    value
 /free
    dcl-s l_countr like(countr);
    
    exec sql SELECT COUNTR INTO :l_countr
             FROM COUNTRY
             WHERE COID = :P_COID;
             
    return l_countr;
 /end-free
pGetCountryName   e

*=============================================
PGetCountryIso3   B                     export
DGetCountryIso3   PI                   like(coiso)
D P_COID                         2A    value
 /free
    dcl-s l_coiso like(coiso);
    
    exec sql SELECT COISO INTO :l_coiso
             FROM COUNTRY
             WHERE COID = :P_COID;
             
    return l_coiso;
 /end-free
pGetCountryIso3   e

*=============================================
P ExistCountry    B                     export
D ExistCountry    PI              n
D P_COID                         2A    value
 /free
    dcl-s l_count int(5);
    
    exec sql SELECT COUNT(*) INTO :l_count
             FROM COUNTRY
             WHERE COID = :P_COID;
             
    return l_count > 0;
 /end-free
p ExistCountry    e

p chainCOUNTRY    b
d chainCOUNTRY    pi
D P_COID                         2A    value
 /free
    // This procedure is kept for backward compatibility
    // but internally uses SQL instead of record-level access
    exec sql SELECT COID, COUNTR, COISO
             INTO :COID, :COUNTR, :COISO
             FROM COUNTRY
             WHERE COID = :P_COID;
 /end-free
p chainCOUNTRY    e

p closeCOUNTRY    b
d closeCOUNTRY    pi
 /free
    // This procedure is kept for backward compatibility
    // but does nothing since SQL handles connections
 /end-free
p closeCOUNTRY    e
```

#### COU301.SQLRPGLE (replacing COU301.RPGLE)

Convert the subfile program to use SQL for data access:

```rpgle
h nomain

/copy qprotosrc,country

// ... (existing display file and indicator declarations) ...

*=============================================
P sltcountry      B                   export
D sltcountry      PI                  like(coid)
d pcod                                like(coid)
// ... (existing variable declarations) ...
 /free
  if not %open(cou301d);
    open cou301d;
  endif;
  keycod = pcod;
  dft = pcod;
  bydesc = *off;
  dow step01 <> ' ';
    select;
    when step01 = prp;
      exsr s01prp;
    when step01 = lod;
      exsr s01lod;
    when step01 = dsp;
      exsr s01dsp;
    when step01 = key;
      exsr s01key;
    when step01 = chk;
      exsr s01chk;
    when step01 = act;
      exsr s01act;
    endsl;
  enddo;
  return dft;
  
  //--- Clear Subfile  -----------------------------------------------------
  begsr s01prp;
    RRS01 = 0;
    clear CTL01;
    sflclr = *on;
    sfldsp = *off;
    sfldspctl = *off;
    write CTL01;
    sflclr = *off;
    
    // Replace record-level access with SQL
    if not bydesc;
      exec sql DECLARE C1 CURSOR FOR
               SELECT COID, COUNTR, COISO
               FROM COUNTRY
               WHERE COID >= :KEYCOD
               ORDER BY COID;
      exec sql OPEN C1;
      exec sql FETCH C1 INTO :COID, :COUNTR, :COISO;
      SflEnd = SQLCODE <> 0;
    else;
      exec sql DECLARE C2 CURSOR FOR
               SELECT COID, COUNTR, COISO
               FROM COUNTRY
               WHERE COUNTR >= :KEYDES
               ORDER BY COUNTR;
      exec sql OPEN C2;
      exec sql FETCH C2 INTO :COID, :COUNTR, :COISO;
      SflEnd = SQLCODE <> 0;
    endif;
    
    SAVCOD = coid;
    SAVDES = countr;
    Step01 = lod;
  endsr;
  
  //--- Load Subfile  -----------------------------------------------------
  begsr S01lod;
    RRN01 = RRS01;
    RRB01 = RRS01 + 1;
    TELLER = 0;
    OPT01 = 0;
    SflNxtChg = *OFF;
    coid = SAVCOD;
    countr = SAVDES;
    
    dow not sflend and TELLER < 20;
      RRN01 = RRN01 + 1;
      TELLER = TELLER + 1;
      write SFL01;
      
      if not bydesc;
        exec sql FETCH C1 INTO :COID, :COUNTR, :COISO;
      else;
        exec sql FETCH C2 INTO :COID, :COUNTR, :COISO;
      endif;
      
      SflEnd = SQLCODE <> 0;
    enddo;
    
    SAVCOD = coid;
    SAVDES = countr;
    RRS01 = RRN01;
    Step01 = dsp;
  endsr;
  
  // ... (rest of the subroutines) ...
  
  // Close cursors when done
  begsr s01act;
    Step01 = dsp;
    select;
    when IN08;
      Step01 = prp;
      bydesc = not bydesc;
      if bydesc;
        clear KEYdes;
      else;
        clear KEYcod;
      endif;
      
      // Close any open cursors
      exec sql CLOSE C1;
      exec sql CLOSE C2;
      
    // ... (rest of the action subroutine) ...
    endsl;
  endsr;
 /end-free
P sltcountry      E
```

## 4. Ensuring Backward Compatibility

### Interface Compatibility

1. **Maintain the same procedure signatures** in the service modules:
   - `GetCountryName`
   - `GetCountryIso3`
   - `ExistCountry`
   - `sltcountry`

2. **Create SQL Views** that match the original DDS file layouts:
   - Views provide the same field names and types
   - Applications can query views instead of tables directly

3. **Implement compatibility procedures** for record-level access patterns:
   - Keep `chainCOUNTRY` and `closeCOUNTRY` procedures but implement them using SQL
   - These procedures maintain the same interface but use SQL internally

### Data Type Mapping

| DDS Type | SQL Type |
|----------|----------|
| A (Character) | CHAR or VARCHAR |
| P (Packed) | DECIMAL |
| S (Zoned) | DECIMAL |
| B (Binary) | SMALLINT, INTEGER, or BIGINT |
| L (Date) | DATE |
| T (Time) | TIME |
| Z (Timestamp) | TIMESTAMP |

## 5. Migration Strategy

### Phase 1: Preparation

1. **Create SQL DDL scripts** for all tables and indexes
2. **Create compatibility views** to match original file layouts
3. **Develop test cases** to validate data access before and after migration

### Phase 2: Database Migration

1. **Create new SQL tables** alongside existing DDS files
2. **Populate SQL tables** with data from DDS files:
   ```sql
   INSERT INTO COUNTRY (COID, COUNTR, COISO)
   SELECT COID, COUNTR, COISO FROM QDDSSRC.COUNTRY;
   ```
3. **Create indexes** on the new SQL tables
4. **Validate data** in the new tables matches the original files

### Phase 3: Code Migration

1. **Create new SQLRPGLE versions** of the service modules
2. **Test the new modules** with the SQL tables
3. **Update service program** to use the new modules:
   ```
   CRTSRVPGM SRVPGM(&O/&N) MODULE(COU300SQL COU301SQL) ACTGRP(*CALLER) +
      EXPORT(*SRCFILE) SRCFILE(*LIBL/QSRVSRC) SRCMBR(*SRVPGM)
   ```

### Phase 4: Deployment

1. **Deploy SQL tables** to production
2. **Deploy updated service programs** to production
3. **Monitor application performance** and address any issues

## 6. Testing Approach

### Unit Testing

1. **Test each refactored procedure** against both DDS and SQL implementations:
   - Verify `GetCountryName` returns the same results
   - Verify `GetCountryIso3` returns the same results
   - Verify `ExistCountry` returns the same results

2. **Test subfile programs** with both implementations:
   - Verify `sltcountry` displays the same data
   - Verify sorting works correctly
   - Verify selection returns the correct values

### Integration Testing

1. **Test CUS200 program** with the refactored service program:
   - Verify customer maintenance works correctly
   - Verify country selection works correctly

2. **Test any other programs** that use the FCOUNTRY service program

### Performance Testing

1. **Compare query performance** between DDS and SQL implementations:
   - Measure response time for key operations
   - Verify SQL indexes are being used effectively

2. **Optimize SQL queries** if performance issues are found:
   - Add additional indexes if needed
   - Review and optimize SQL statements

## 7. Benefits of SQL Migration

1. **Modern database features**:
   - Constraints (PRIMARY KEY, FOREIGN KEY, CHECK)
   - Triggers
   - Stored procedures
   - Advanced SQL functions

2. **Better integration** with modern tools and languages

3. **Improved performance** through SQL query optimization

4. **Enhanced data integrity** through constraints

5. **Simplified maintenance** with standard SQL syntax

## 8. Risks and Mitigation

| Risk | Mitigation |
|------|------------|
| Performance degradation | Proper indexing, SQL tuning, performance testing |
| Data type compatibility issues | Thorough testing, careful data type mapping |
| Application errors | Comprehensive testing, phased rollout |
| Learning curve for developers | Training, documentation, code examples |